## 关于问题 4 解法的说明

问题要求我们对两个已经排序完成的数组寻找它们合在一起的中位数，要求时间复杂度 $ O(log{(m + n)}) $。

对于这个问题，我们可以考虑推广一下：求取两个有序数组的第 K 大的数。

> 按照传统的思路，最直观的解法就是 merge 两个数组，然后求第 K 大的数字，时间复杂度为 $ O(m+n) $，不合题意；

如果想要时间复杂度将为O(log(m+n)，我们可以考虑从 K 入手。如果我们每次能够删除一个一定在第 K 个元素之前的元素，那么我们需要进行 K 次，但是如果每次我们都删除一半呢？由于两个数组都是有序的，我们应该充分利用这个信息。

- 假设 A，B 两个数组的元素都大于 k / 2, 我们将 A, B 两个数组的第 k/2 个元素进行比较。比较的结果又三种情况：

    - A[K/2] == B[K/2], 说明已经找到第 K 个元素了，直接返回 A[K/2]  或者 B[K/2] 即可。
    - A[K/2] > B[K/2], 说明 B[0] 到 B[K/2] 肯定在两个数组的前 K 个元素中，此时我们可以放心的删除 B 数组的这些元素，并求取剩余 B 数组与 A 数组的第 (K - K/2) 的元素；
    - A[K/2] < B[K/2]，原理同上。

- 现在可以考虑当 A 或者 B 的元素个数小于 K/2 的情况：

    - A.size() < K/2 && B.size() > K/2，此时我们可以比较 A 数组中的最大值（假设为 m 项）与 B 数组第 K/2 元素的大小关系：

        - A[m] <= B[K/2], 说明此时 A 数组的全部元素肯定在两个数组的前 K 个元素中，此时可以放心的删除 A 数组的所有元素，然后求取 B 数组中第 (K - m)的元素；
        - A[m] > B[K/2], 说明此时 B[0] 到 B[K/2] 肯定在两个数组的前 K 个元素中，此时我们可以放心的删除 B 数组的这些元素，并求取剩余 B 数组与 A 数组的第 (K - K/2) 的元素；

    - B.size() < K/2 && A.size() > K/2 的情况与上面类似。


这部分代码见 `solution.cpp` 文件中的第 14 到第 21 行。
